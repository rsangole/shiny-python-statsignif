[{"name": "app.py", "content": "from __future__ import annotations\n\nfrom shiny import App, reactive, render, ui, req\nfrom shinywidgets import render_altair\nimport shinyswatch\nimport shiny.experimental as x\nimport pandas as pd\nfrom htmltools import css\nimport numpy as np\nimport altair as alt\nfrom scipy.stats import norm\nimport plotly.express as px\nimport plotly.graph_objects as go\n# import altair as alt    \n# alt.data_transformers.disable_max_rows()\nfrom shinywidgets import output_widget, render_widget\n\nimport matplotlib.pyplot as plt\n\nCOL_GRtreatment = \"#0a9396\"\nCOL_GRcontrol = \"#f95738\"\nCOL_LDA_LINE = \"#ee9b00\"\nCOL_L1 = \"#6c757d\"\nCOL_DIM = \"#e9d8a6\"\nCOL_DIST = \"#06d6a0\"\nALPHA_DIM = 0.4\nLINE_DIM = 0.5\n\n# https://icons.getbootstrap.com/icons/question-circle-fill/\nquestion_circle_fill = ui.HTML(\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" fill=\"gray\" class=\"bi bi-question-circle-fill mb-1\" viewBox=\"0 0 16 16\"> \\\n    <path d=\"M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247zm2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z\"/> \\\n    </svg>'\n)\n\n\napp_ui = ui.page_fluid(\n    ui.panel_title(\"Why \u201cStatistical Significance\u201d Is Pointless\"),\n    ui.br(),\n    ui.p(\n        \"Article author: Samuele Mazzanti\",\n        ui.br(),\n        \"Article link: https://towardsdatascience.com/why-statistical-significance-is-pointless-a7644be30266\"\n    ),\n    # ui.p(\n    #     \"Let's see this in action.\",\n    #     \"Here are two groups of points. \",\n    #     \"The objective is to find a line which best separates the two groups. \",\n    # ),\n    ui.row(\n        ui.column(\n            2,\n            ui.br(),\n            ui.panel_well(\n                # ui.input_select(\n                #     id=\"case\",\n                #     label=x.ui.tooltip(\n                #         ui.span(\"Cases \", question_circle_fill),\n                #         ui.markdown(\n                #             \"Each case here has a different distribution of points.\\\n                #         These points are created using 'multivariate_normal' function from scipy.stats.\"\n                #         ),\n                #     ),\n                #     multiple=False,\n                #     choices={\n                #         \"1\": \"Parallel Ellipses\",\n                #         \"2\": \"Angled Ellipses\",\n                #         \"3\": \"Circles\",\n                #         \"4\": \"Offset Ellipses\",\n                #     },\n                # ),\n                ui.input_numeric(\n                    id=\"treatment_mean\",\n                    label=\"Treatment Mean\",\n                    value=10,\n                    min=0,\n                    max=-20,\n                    step=0.1,\n                ),\n                ui.input_numeric(\n                    id=\"control_mean\",\n                    label=\"Control Mean\",\n                    min=0,\n                    max=20,\n                    value=10.5,\n                    step=0.1,\n                ),\n                ui.input_numeric(\n                    id=\"treatment_cov\",\n                    label=\"Treatment Std Dev\",\n                    value=1,\n                    min=0,\n                    max=10,\n                    step=0.1,\n                ),\n                ui.input_numeric(\n                    id=\"control_cov\",\n                    label=\"Control Std Dev\",\n                    value=1,\n                    min=0,\n                    max=10,\n                    step=0.1,\n                ),\n                ui.input_slider(\n                    id=\"n_points\",\n                    label=\"Points in each group\",\n                    min=10,\n                    max=300,\n                    value=100,\n                    step=10,\n                ),\n                ui.input_slider(\n                    id=\"n_permutations\",\n                    label=\"Permutations\",\n                    min=1000,\n                    max=10000,\n                    value=10000,\n                    step=1000,\n                ),\n                ui.hr(),\n                ui.input_action_button(\"generate\", \"Generate\"),\n            ),\n            ui.br(),\n            # ui.panel_well(\n            #     ui.input_slider(\n            #         \"angle\",\n            #         x.ui.tooltip(\n            #             ui.span(\"Angle of Line L \", question_circle_fill),\n            #             \"The angle of the arbitrary line L\",\n            #         ),\n            #         0,\n            #         180,\n            #         20,\n            #         step=1,\n            #         post=\"\u00b0\",\n            #     ),\n            # ),\n            # ui.br(),\n            # ui.panel_well(\n            #     ui.input_checkbox(\"plot_proj_L1\", \"Projections on L\", False),\n            #     ui.input_checkbox(\n            #         \"plot_proj_lda\",\n            #         \"Projections on LDA\",\n            #         False,\n            #     ),\n            # ),\n        ),\n        ui.column(\n            10,\n            ui.row(\n                ui.column(\n                    6,\n                    output_widget(\n                        \"treatment_control_hist\", height=\"400px\", width=\"400px\"\n                    ),\n                    ui.output_text(\"txt_pop_dif\"),  \n                    ui.output_text(\"txt_sample_dif\"),  \n                    #         ui.HTML(\n                    #             f\"The plot shows you two lines: an optimal separator selected by <span style='color:{COL_LDA_LINE};'>LDA</span> and an arbitrary <span style='color:{COL_L1};'>line L</span> that is not optimal.\"\n                    #         ),\n                    #         ui.HTML(\n                    #             f\" The numbers in the four corners display the variance of each point cloud when projected on the <span style='color:{COL_LDA_LINE};'>LDA line (indicated by \u25bc)</span> or the arbitrary <span style='color:{COL_L1};'>line L (indicated by +)</span>. You can turn on the projections using the buttons on the left.\"\n                    #         ),\n                ),\n                ui.column(\n                    6,\n                    output_widget(\"permutation_hist\", height=\"400px\", width=\"400px\"),\n                    ui.output_text(\"txt_perm\"),  \n\n                    #         ui.output_plot(\"plot_by_angle\", height=\"600px\", width=\"600px\"),\n                    #         ui.HTML(\n                    #             \"This graph visualizes the trade-offs between intra-group variance and inter-group distance as the angle of projection changes.\",\n                    #         ),\n                    #         ui.HTML(\n                    #             f\"  The ideal angle - given by <span style='color:{COL_LDA_LINE};'>LDA</span> - has the best balance between <i>minimizing</i> within-group-variance and <i>maximizing</i> between-group-distance.\",\n                    #         ),\n                ),\n            ),\n        ),\n    ),\n    ui.br(),\n    ui.row(\n        ui.HTML(\n            \"<div style='text-align: center; color: gray; font-size:0.9em;'> Created using Shiny for Python | <a href = 'http://www.rsangole.com'>Rahul Sangole</a> | Dec '24</div>\"\n        )\n    ),\n\n    theme=shinyswatch.theme.cosmo,\n)\n\n\ndef server(input, output, session):\n    @reactive.Calc\n    @reactive.event(input.generate, ignore_none=False)\n    def treatment():\n        return norm.rvs(input.treatment_mean(), input.treatment_cov(), input.n_points())\n\n    @reactive.Calc\n    @reactive.event(input.generate, ignore_none=False)\n    def control():\n        return norm.rvs(input.control_mean(), input.control_cov(), input.n_points())\n\n    @reactive.Calc\n    @reactive.event(input.generate, ignore_none=False)\n    def permute():\n        combined = np.concatenate([treatment(), control()])\n        permutation_results = []\n        for _ in range(input.n_permutations()):\n            combined = np.random.permutation(combined)\n            perm_treatment = combined[: len(treatment())]\n            perm_control = combined[-len(treatment()) :]\n            permutation_results.append(np.mean(perm_treatment) - np.mean(perm_control))\n        return permutation_results\n\n    @render_widget\n    def treatment_control_hist():\n        res = pd.DataFrame(\n            {\"Treatment\": treatment(), \"Control\": control()},\n            index=range(len(treatment())),\n        ).melt()\n        fig = (\n            px.histogram(\n                res,\n                x=\"value\",\n                color=\"variable\",\n                marginal=\"rug\",\n                color_discrete_sequence=[COL_GRtreatment, COL_GRcontrol],\n                # opacity=0.75,\n            )\n            .update_layout(\n                title={\"text\": \"\", \"x\": 0.5},\n                yaxis_title=\"Count\",\n                xaxis_title=\"Treatment, Control Values\",\n                legend_title=\"\",\n                legend=dict(\n                    orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1\n                ),\n                plot_bgcolor=\"white\",\n                paper_bgcolor=\"white\",\n            )\n        )\n        return fig\n\n    @render_widget\n    def permutation_hist():\n        res = pd.DataFrame(permute(), columns=[\"Permutation\"]).melt()\n        mean_diff = np.mean(res[\"value\"])\n        fig = px.histogram(\n            res,\n            x=\"value\",\n            color=\"variable\",\n            marginal=\"rug\",\n            color_discrete_sequence=[COL_L1],\n        ).update_layout(\n            title={\"text\": \"\", \"x\": 0.5},\n            yaxis_title=\"Count\",\n            xaxis_title=\"Difference in Means\",\n            legend_title=\"\",\n            plot_bgcolor=\"white\",\n            paper_bgcolor=\"white\",\n            legend=dict(\n                orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1\n            ),\n        )\n        fig.add_shape(\n            type=\"line\",\n            x0=mean_diff,\n            y0=0,\n            x1=mean_diff,\n            y1=1,\n            xref=\"x\",\n            yref=\"paper\",\n            line=dict(\n                # color=\"DarkGray\",\n                width=2,\n                dash=\"dash\",\n            ),\n        )\n        fig.add_annotation(\n            x=mean_diff,\n            y=1,\n            xref=\"x\",\n            yref=\"paper\",\n            text=f\"Mean {mean_diff:.3f}\",\n            showarrow=False,\n            yshift=1,\n            xanchor=\"left\",\n            # font=dict(color=\"LightGray\"),\n        )\n\n        return fig\n    \n    @render.text  \n    def txt_pop_dif():\n        return f\"Population Mean Difference: {input.treatment_mean() - input.control_mean():.3f}\"\n    \n    @render.text  \n    def txt_sample_dif():\n        return f\"Sample Mean Difference: {np.mean(treatment()) - np.mean(control()):.3f}\"\n    \n    @render.text  \n    def txt_perm():\n        return f\"How likely is it to get a result as extreme as {np.mean(treatment()) - np.mean(control()):.3f}? To answer this, we just need to compute the percentage of experiments that had an outcome higher than {np.mean(treatment()) - np.mean(control()):.3f}\"\n\n\napp = App(app_ui, server)\n", "type": "text"}]